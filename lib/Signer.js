const randomBytes = require('crypto').randomBytes
const bcrypt = require('bcrypt')
const validator = require('validator')
const Boom = require('boom')

const RegexValidator = require('./RegexValidator')

class Signer {
  /**
   * Generates cryptographically strong pseudo-random data of the set length.
   * @param {number} [length=16] Length of data to generate, in bytes
   * @return {Promise} Resolves with a buffer containing the generated bytes
   */
  static randomBytes (length = 16) {
    return new Promise((resolve, reject) => {
      randomBytes(length, (err, buffer) => {
        if (err) return reject(err)
        return resolve(buffer)
      })
    })
  }

  /**
   * Generates a sign secret from a cryptographically strong source. This method
   * returns a hexadecimal string of the set length.
   * @param {number} [length=32] Length of secret to generare
   * @return {Promise} Resolves with the sign secret
   */
  static generateSignSecret (length = 32) {
    return Signer.randomBytes(Math.floor(length / 2)).then(buffer => {
      return buffer.toString('hex')
    })
  }

  /**
   * Checks to see if the given string is a valid hexadecimal string of the
   * correct length.
   * @param {string} [signSecret=null] The sign secret string to test
   * @param {number} [length=32] How many characters the sign secret should be
   * @return {Promise} Resolves if the sign secret is valid
   */
  static isValidSignSecret (signSecret = null, length = 32) {
    if (!signSecret || signSecret === null || !validator.isHexadecimal(signSecret) || signSecret.length !== length) {
      return Promise.reject(Boom.badRequest('invalid sign secret'))
    }
    return Promise.resolve()
  }

  /**
   * Hash a plain-text password with bcrypt.
   * @param {string} [password=null] The password to hash
   * @param {number} [saltRounds=10] Number of salt rounds to perform
   * @return {Promise} Resolves with the password's hash
   */
  static hashPassword (password = null, saltRounds = 10) {
    return RegexValidator.isValidPassword(password).then(() => {
      return bcrypt.hash(password, saltRounds)
    })
  }

  /**
   * Compare a plain-text password with a bcrypt generated password hash.
   * @param {string} [passwordPlain=null]    The plain-text password
   * @param {string} [passwordHash=null]     The password hash to compare to
   * @param {boolean} [rejectOnInvalid=true] Reject the promise if the password is invalid
   * @return {Promise} Resolves if the password was correct
   */
  static comparePassword (passwordPlain = null, passwordHash = null, rejectOnInvalid = true) {
    return RegexValidator.isValidPassword(passwordPlain).then(() => {
      return RegexValidator.isValidBcryptHash(passwordHash)
    }).then(() => {
      return bcrypt.compare(passwordPlain, passwordHash)
    }).then(valid => {
      if (!valid && rejectOnInvalid) {
        return Promise.reject(Boom.forbidden('password mismatch'))
      }
      return Promise.resolve(valid)
    })
  }
}

exports = module.exports = Signer
